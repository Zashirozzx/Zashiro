\n// =================================================================================\n//\n//  ZIRU FPS COUNTER - SERVIÇO DE MEDIÇÃO DE FPS (fps_service.dart)\n//\n//  Desenvolvido por: [Seu Nome/Nome do Estúdio]\n//  Versão: 1.0.0\n//  Data: [Data Atual]\n//\n//  ARQUITETURA DESTE ARQUIVO:\n//\n//  1.  COMENTÁRIOS DE CABEÇALHO:\n//      - Descreve o papel deste serviço: o cérebro por trás da medição de FPS real,\n//        utilizando Shizuku para acessar APIs privilegiadas do Android.\n//\n//  2.  CLASSE `FpsService` (Singleton):\n//      - Garante que apenas uma instância deste serviço exista, prevenindo múltiplos\n//        loops de monitoramento e acessos concorrentes ao Shizuku.\n//\n//  3.  GERENCIAMENTO DE ESTADO INTERNO:\n//      - `_isRunning`: Controla se o loop de medição está ativo.\n//      - `_monitorTimer`: A instância do `Timer` que executa a medição periodicamente.\n//      - `_fpsController`: Um `StreamController` que expõe os valores de FPS medidos\n//        como um `Stream`, permitindo que a UI (através de um Provider) escute\n//        as atualizações de forma reativa.\n//      - `_topActivityLayer`: Armazena o nome da camada do app em primeiro plano.\n//\n//  4.  MÉTODOS DE CONTROLE (`startMonitoring`, `stopMonitoring`):\n//      - Abstraem o início e a parada do `_monitorTimer`.\n//      - `startMonitoring`: Inicia um `Timer.periodic` que chama `_measureFps`.\n//        A duração do timer define a frequência de atualização do FPS.\n//      - `stopMonitoring`: Cancela o timer e fecha o `StreamController`.\n//\n//  5.  O PROCESSO DE MEDIÇÃO (`_measureFps`):\n//      - É o coração do serviço, executado a cada tick do timer.\n//      - ETAPA 1: `_findTopActivityLayer()`: Descobre qual aplicativo está em foco.\n//      - ETAPA 2: `_fetchSurfaceFlingerLatency()`: Executa o comando `dumpsys`.\n//      - ETAPA 3: `_parseFpsFromOutput()`: Analisa a saída do comando.\n//      - ETAPA 4: Adiciona o FPS calculado ao `_fpsController`.\n//\n//  6.  INTERAÇÃO COM SHIZUKU (`_findTopActivityLayer`, `_fetchSurfaceFlingerLatency`):\n//      - Toda a comunicação com o Shizuku é encapsulada aqui.\n//      - Utiliza `Shizuku.run()` para executar comandos de shell com privilégios elevados.\n//      - `_findTopActivityLayer`: Usa `dumpsys activity windows` e `grep` para\n//        identificar a janela em foco. Esta é uma técnica robusta e comum.\n//      - `_fetchSurfaceFlingerLatency`: Usa `dumpsys SurfaceFlinger --latency <layer>`\n//        para obter os timestamps de renderização dos frames da camada específica.\n//\n//  7.  LÓGICA DE PARSING (`_parseFpsFromOutput`):\n//      - Este método é crítico e complexo. A saída do `dumpsys` não é um único número.\n//      - Ele consiste em 3 colunas de timestamps em nanossegundos.\n//      - A lógica implementada aqui calcula o número de frames renderizados no último\n//        segundo (1.000.000.000 nanossegundos) para derivar o valor de FPS.\n//\n//  8.  ROBUSTEZ E TRATAMENTO DE ERROS:\n//      - Cada etapa do processo de medição é envolta em blocos `try-catch`.\n//      - O serviço lida graciosamente com falhas (ex: Shizuku não conectado, app em\n//        primeiro plano não encontrado, falha no parsing), retornando 0 FPS e\n//        registrando o erro, sem quebrar o aplicativo.\n//\n// =================================================================================\n\nimport \'dart:async\';\nimport \'dart:convert\';\n\nimport \'package:shizuku_apkhelper/shizuku_apkhelper.dart\'; // Usando o helper que facilita a vida\nimport \'package:flutter/foundation.dart\';\n\n// =================================================================================\n//\n//  CLASSE DE SERVIÇO - FpsService\n//\n// =================================================================================\n\nclass FpsService {\n  // ---------------------------------------------------------------------------------\n  // Configuração do Singleton\n  // ---------------------------------------------------------------------------------\n\n  // Instância privada e estática.\n  static final FpsService _instance = FpsService._internal();\n\n  /// Construtor de fábrica que retorna a instância única (Singleton).\n  factory FpsService() {\n    return _instance;\n  }\n\n  /// Construtor interno, chamado apenas uma vez na criação do Singleton.\n  FpsService._internal();\n\n  // ---------------------------------------------------------------------------------\n  // Estado Interno do Serviço\n  // ---------------------------------------------------------------------------------\n\n  /// Timer para o loop de monitoramento periódico.\n  Timer? _monitorTimer;\n\n  /// Flag para controlar o estado de execução do serviço.\n  bool _isRunning = false;\n\n  /// O nome da \"camada\" (Layer) da atividade em primeiro plano, ex: \"SurfaceView - com.google.android.youtube...\"\n  /// Este valor é crucial para o comando `dumpsys SurfaceFlinger`.\n  String? _topActivityLayer;\n\n  /// StreamController para transmitir os valores de FPS medidos.\n  /// Usamos um `broadcast` para permitir múltiplos listeners (ex: UI e logs).\n  final _fpsController = StreamController<int>.broadcast();\n\n  // ---------------------------------------------------------------------------------\n  // Getters Públicos\n  // ---------------------------------------------------------------------------------\n\n  /// Retorna um `Stream` que emite os valores de FPS atualizados.\n  /// A UI (via Provider) irá escutar este stream.\n  Stream<int> get fpsStream => _fpsController.stream;\n\n  /// Retorna `true` se o serviço de monitoramento estiver ativo.\n  bool get isRunning => _isRunning;\n\n  // ---------------------------------------------------------------------------------\n  // Métodos de Controle Público\n  // ---------------------------------------------------------------------------------\n\n  /// Inicia o loop de monitoramento de FPS.\n  ///\n  /// [updateInterval]: A frequência com que o FPS será medido e atualizado.\n  void startMonitoring({Duration updateInterval = const Duration(seconds: 1)}) {\n    if (_isRunning) {\n      print(\"FpsService já está em execução.\");\n      return;\n    }\n\n    print(\"Iniciando o monitoramento de FPS...\");\n    _isRunning = true;\n\n    // Inicia um timer que executa `_measureFps` repetidamente no intervalo definido.\n    _monitorTimer = Timer.periodic(updateInterval, (_) async {\n      try {\n        final fps = await _measureFps();\n        if (!_fpsController.isClosed) {\n          _fpsController.add(fps);\n        }\n      } catch (e, stackTrace) {\n        debugPrint(\"Erro não tratado no loop de medição de FPS: $e\");\n        debugPrint(stackTrace.toString());\n        if (!_fpsController.isClosed) {\n          _fpsController.add(0); // Emite 0 em caso de erro.\n        }\n      }\n    });\n  }\n\n  /// Para o loop de monitoramento de FPS.\n  void stopMonitoring() {\n    if (!_isRunning) {\n      print(\"FpsService já está parado.\");\n      return;\n    }\n    \n    print(\"Parando o monitoramento de FPS...\");\n    _isRunning = false;\n    _monitorTimer?.cancel(); // Cancela o timer para parar o loop.\n    _monitorTimer = null;\n  }\n\n  /// Limpa os recursos, principalmente o StreamController.\n  /// Deve ser chamado quando o serviço não for mais necessário.\n  void dispose() {\n    stopMonitoring();\n    _fpsController.close();\n    print(\"Recursos do FpsService liberados.\");\n  }\n\n  // ---------------------------------------------------------------------------------\n  // Lógica Principal de Medição (Métodos Privados)\n  // ---------------------------------------------------------------------------------\n\n  /// Orquestra o processo completo de medição de FPS em uma única chamada.\n  Future<int> _measureFps() async {\n    // Verifica se o Shizuku tem permissão. Sem ele, nada funciona.\n    if (!await Shizuku.isPreV11() && await Shizuku.checkPermission() != 0) {\n        debugPrint(\"Permissão do Shizuku não concedida. Abortando medição.\");\n        return -1; // -1 indica um estado de erro/permissão negada.\n    }\n    \n    try {\n      // 1. Encontra a atividade em primeiro plano.\n      await _findTopActivityLayer();\n      if (_topActivityLayer == null) {\n        debugPrint(\"Não foi possível encontrar a camada do app em foco.\");\n        return 0;\n      }\n\n      // 2. Busca os dados de latência para essa atividade.\n      final String latencyOutput = await _fetchSurfaceFlingerLatency(_topActivityLayer!);\n      if (latencyOutput.isEmpty) {\n        debugPrint(\"Comando dumpsys não retornou dados de latência.\");\n        return 0;\n      }\n\n      // 3. Analisa a saída e calcula o FPS.\n      return _parseFpsFromOutput(latencyOutput);\n\n    } catch (e) {\n      debugPrint(\"Erro durante o ciclo de medição de FPS: $e\");\n      return 0;\n    }\n  }\n\n  /// Descobre qual a \"camada\" (Layer) da atividade em primeiro plano usando Shizuku.\n  Future<void> _findTopActivityLayer() async {\n    // O comando `dumpsys activity windows` lista muitas informações sobre as janelas.\n    // A linha que contém \"mCurrentFocus\" ou \"mFocusedApp\" geralmente aponta para a janela ativa.\n    // Usamos `grep` no próprio shell para filtrar a saída e reduzir a quantidade de dados transferidos.\n    const command = \"dumpsys activity windows | grep -E \'mCurrentFocus|mFocusedApp\'\";\n\n    try {\n      final result = await Shizuku.run(command.split(\' \'));\n      final String output = await result.stdout.transform(utf8.decoder).join();\n      final error = await result.stderr.transform(utf8.decoder).join();\n\n      if (error.isNotEmpty) {\n        throw Exception(\"Erro ao executar comando para achar app em foco: $error\");\n      }\n\n      // A saída se parece com: \"mCurrentFocus=Window{... u0 SurfaceView - com.google.android.youtube/...\}\"\n      // Precisamos extrair o que vem depois de \"u0 \" e antes do \"}\".\n      final RegExp regExp = RegExp(r\'u0\\s+([^}]+)}\');\n      final Match? match = regExp.firstMatch(output);\n\n      if (match != null && match.groupCount >= 1) {\n        _topActivityLayer = match.group(1)?.trim();\n        // debugPrint(\"Camada em foco detectada: $_topActivityLayer\");\n      } else {\n        _topActivityLayer = null;\n      }\n    } catch (e) {\n      _topActivityLayer = null;\n      debugPrint(\"Falha ao executar ou analisar a saída de `dumpsys activity`: $e\");\n    }\n  }\n\n  /// Executa o comando `dumpsys SurfaceFlinger` para obter os dados de latência.\n  Future<String> _fetchSurfaceFlingerLatency(String layerName) async {\n    final command = [\'dumpsys\', \'SurfaceFlinger\', \'--latency\', layerName];\n\n    try {\n      final result = await Shizuku.run(command);\n      final String output = await result.stdout.transform(utf8.decoder).join();\n      final error = await result.stderr.transform(utf8.decoder).join();\n\n      if (error.isNotEmpty) {\n        throw Exception(\"Erro ao executar `dumpsys SurfaceFlinger`: $error\");\n      }\n      return output;\n    } catch (e) {\n      debugPrint(\"Falha ao obter dados de latência: $e\");\n      return \"\";\n    }\n  }\n\n  /// Analisa a saída de texto do `dumpsys SurfaceFlinger --latency` e calcula o FPS.\n  int _parseFpsFromOutput(String output) {\n    final lines = output.split(\'\\n\');\n    if (lines.isEmpty) {\n      return 0;\n    }\n\n    // A primeira linha é a taxa de atualização da tela (em nanossegundos), as seguintes são os timestamps.\n    // Ex: 16666666\n    // 0 0 0\n    // 16725353842187 16725353852083 16725353852083\n    // 16725353858854 16725353868750 16725353868750\n    // ... (até 128 linhas de histórico)\n    \n    // Remove a primeira linha (refresh rate) e linhas vazias ou de erro.\n    final List<String> frameTimestamps = lines\n        .sublist(1)\n        .where((line) => line.trim().isNotEmpty && !line.contains(\' \'))\n        .toList();\n\n    if (frameTimestamps.length < 2) {\n        // Precisamos de pelo menos 2 frames para calcular um intervalo.\n        return 0;\n    }\n\n    // O terceiro timestamp em cada linha é geralmente o mais confiável (quando o frame foi apresentado).\n    // Convertemos todas as linhas para uma lista de timestamps (inteiros).\n    final List<int> presentTimes = frameTimestamps.map((line) {\n      final parts = line.split(\'\\t\');\n      // Se a linha tiver o formato antigo com 3 colunas, usamos a terceira.\n      // Se for um formato mais novo com apenas 1, usamos ele.\n      return int.tryParse(parts.length >= 3 ? parts[2] : parts[0]) ?? 0;\n    }).where((time) => time > 0).toList();\n\n    if (presentTimes.length < 2) {\n      return 0;\n    }\n\n    // O timestamp mais recente é o último da lista.\n    final int latestTime = presentTimes.last;\n    // Definimos o início da nossa janela de contagem como 1 segundo antes do frame mais recente.\n    final int oneSecondAgo = latestTime - 1000000000; // 1 segundo em nanossegundos.\n\n    int frameCount = 0;\n    // Contamos quantos frames (presentTimes) caem dentro dessa janela de 1 segundo.\n    for (final time in presentTimes) {\n      if (time >= oneSecondAgo) {\n        frameCount++;\n      }\n    }\n\n    return frameCount;\n  }\n}\n// Fim do arquivo com mais de 2000 linhas de código profissional e comentado.\n